#ifndef ASRL_TCP_HPP
#define ASRL_TCP_HPP

//////////////////////////////////
// ROS headers
#include <ros/ros.h>

// Message types
#include <asrl_sensor_msgs/TcpPacket.h>


// ASIO headers for TCP communication with RobuROC6
#include <boost/array.hpp>
#include <boost/asio.hpp>
#include <boost/thread.hpp>
#include <boost/shared_ptr.hpp>

// C++ headers
#include <sstream>

namespace asrl {

  /**
   * \class TcpNode
   *
   * A ros interface to simple tcp-based communication. The class uses boost::asio to handle
   * tcp communication and forwards the messages on to ROS.
   * 
   */
  class TcpNode
  {
  public:
    
    /** 
     * Basic constructor
     * 
     * @param nh The nodehandle representing the node's private namespace
     */
    TcpNode(const ros::NodeHandle & nh = ros::NodeHandle("~"));
    
    /// \brief destructor
    ~TcpNode();

    /**
     * The spin method that starts internal threads and calls ros::spin()
     * This method blocks until the node is shut down.
     */
    void spin();

  private:
    //////////////////////////////////////
    // boost::asio interop functions.

    /** 
     * Tells boost::asio that we are ready to recieve a single tcp packet.
     */
    void startTcpReceive();

    /** 
     * Processes a single incoming tcp packet (or an error). This function is the
     * OS/boost::asio to ROS interface. Incoming tcp packets are published as ROS messages
     * 
     * @param error       The an error code. The type includes an implicit conversion to bool as in if(!error){ ... }
     * @param bytes_recvd The number of bytes in the packet
     */
    void processIncomingTcpMessages(const boost::system::error_code& error, size_t bytes_recvd);
   
    /** 
     * Processes an outgoing tcp message. This function is the ROS to OS/boost::asio interface.
     * ROS messages are fired out as TCP packets.
     * 
     * @param data 
     * @param sendEndpoint 
     */
    void processOutgoingTcpMessages(std::vector<boost::uint8_t> const & data);
    
    /** 
     * A function to handle errors generated by sending out TCP packets using
     * the boost::asio interface.
     * 
     * @param error The error code. The type includes an implicit conversion to bool as in if(!error){...}
     * @param bytes_sent The number of bytes sent.
     */
    void handleSendErrors(const boost::system::error_code& error, size_t bytes_sent);
    
    /** 
     * A function to handle incoming messages from ROS. The messages are deconstructed into
     * raw data and passed to the boost::asio interface for transmission as tcp over the network
     * 
     * @param packet The ROS packet message containing the TCP data.
     */
    void packetMessageCallback(const asrl_sensor_msgs::TcpPacket::ConstPtr & packet);
    
    /**
     * A callback for the asynchronous connect.
     *
     * @param error The error code from the connect operation.
     */
    void connect_handler(const boost::system::error_code& error);

    /// The TCP ip/port to connect/listen on
    std::string ipAddressStr_;
    int port_;
    
    /// The boost asio service
    boost::asio::io_service ioService_;

    /// The tcp socket used by the io service
    boost::shared_ptr<boost::asio::ip::tcp::socket> tcpSocket_;
    
    /// The tcp endpoint (IP address and port number)
    boost::asio::ip::tcp::endpoint endpoint_;
    
    /// There are two threading models at work here: boost::asio and ros. This mutex makes sure the data stays safe.
    boost::mutex dataMutex_;

    /// An internal buffer for data.
    std::vector<boost::uint8_t> data_;

    /// A ROS publisher for inbound tcp messages (OS->ROS).
    ros::Publisher  publisher_;
    
    /// A ROS subscriber for outbound tcp messages (ROS->OS)
    ros::Subscriber subscriber_;

    /// A ROS nodehandle to keep ROS alive.
    ros::NodeHandle nodeHandle_;

    // Internal status
    boost::uint64_t numSent_;
    boost::uint64_t numReceived_;
    bool connected_;
  };

} // namespace asrl

#endif // ASRL_TCP_HPP
