#ifndef ASRL_UDP_HPP
#define ASRL_UDP_HPP

//////////////////////////////////
// ROS headers
#include <ros/ros.h>

// Message types
#include <asrl_sensor_msgs/Packet.h>


// ASIO headers for UDP communication with RobuROC6
#include <boost/array.hpp>
#include <boost/asio.hpp>
#include <boost/thread.hpp>
#include <boost/shared_ptr.hpp>

// C++ headers
#include <sstream>

namespace asrl {

  /**
   * \class UdpNode
   *
   * A ros interface to simple udp-based communication. The class uses boost::asio to handle
   * udp communication and forwards the messages on to ROS.
   * 
   */
  class UdpNode
  {
  public:
    
    /** 
     * Basic constructor
     * 
     * @param nh The nodehandle representing the node's private namespace
     */
    UdpNode(const ros::NodeHandle & nh = ros::NodeHandle("~"));
    
    /// \brief destructor
    ~UdpNode();

    /**
     * The spin method that starts internal threads and calls ros::spin()
     * This method blocks until the node is shut down.
     */
    void spin();

  private:
    //////////////////////////////////////
    // boost::asio interop functions.

    /** 
     * Tells boost::asio that we are ready to recieve a single udp packet.
     */
    void startUdpReceive();

    /** 
     * Processes a single incoming udp packet (or an error). This function is the 
     * OS/boost::asio to ROS interface. Incoming udp packets are published as ROS messages
     * 
     * @param error       The an error code. The type includes an implicit conversion to bool as in if(!error){ ... }
     * @param bytes_recvd The number of bytes in the packet
     */
    void processIncomingUdpMessages(const boost::system::error_code& error, size_t bytes_recvd);
   
    /** 
     * Processes an outgoing udp message. This function is the ROS to OS/boost::asio interface.
     * ROS messages are fired out as UDP packets.
     * 
     * @param data 
     * @param sendEndpoint 
     */
    void processOutgoingUdpMessages(std::vector<boost::uint8_t> const & data, boost::asio::ip::udp::endpoint sendEndpoint);
    
    /** 
     * A function to handle errors generated by sending out UDP packets using
     * the boost::asio interface.
     * 
     * @param error The error code. The type includes an implicit conversion to bool as in if(!error){...}
     * @param bytes_sent The number of bytes sent.
     */
    void handleSendErrors( const boost::system::error_code& error, size_t bytes_sent);
    
    /** 
     * A function to handle incoming messages from ROS. The messages are deconstructed into
     * raw data and passed to the boost::asio interface for transmission as udp over the network
     * 
     * @param packet The ROS packet message containing the UDP data.
     */
    void packetMessageCallback(const asrl_sensor_msgs::Packet::ConstPtr & packet);

    /** 
     * Helper functionality to translate a ROS ip address to boost format
     * \todo remove the udp::IpAddress type and replace with a string
     *
     * @param ip the ros IP address
     * 
     * @return the boost ASIO equivalent.
     */
    boost::asio::ip::address_v4 rosIpToBoostIp(asrl_sensor_msgs::IpAddress const & ip);

    /** 
     * Helper functionality to translate a ROS ip address to boost format
     * \todo remove the udp::IpAddress type and replace with a string
     *
     * @param ip the boost::asio IP address
     * 
     * @return the ros equivalent
     */
    asrl_sensor_msgs::IpAddress boostIpToRosIp(boost::asio::ip::address_v4 const & ip);
    
    /// The UDP port to listen on.
    int listenPort_;
    
    /// The boost asio service
    boost::asio::io_service ioService_;

    /// The udp socket used by the io service
    boost::shared_ptr<boost::asio::ip::udp::socket> udpSocket_;
    
    /// The udp destination endpoint (IP address and port number)
    boost::asio::ip::udp::endpoint destinationEndpoint_;

    /// The udp source endpoint (IP address and port number)
    boost::asio::ip::udp::endpoint sourceEndpoint_;
    
    /// There are two threading models at work here: boost::asio and ros. This mutex makes sure the data stays safe.
    boost::mutex dataMutex_;
    /// An internal buffer for data.
    std::vector<boost::uint8_t> data_;

    /// A ROS publisher for inbound udp messages (OS->ROS).
    ros::Publisher  publisher_;
    
    /// A ROS subscriber for outbound udp messages (ROS->OS)
    ros::Subscriber subscriber_;

    /// A ROS nodehandle to keep ROS alive.
    ros::NodeHandle nodeHandle_;

    boost::uint64_t numSent_;
    boost::uint64_t numReceived_;
    
  };

} // namespace asrl

#endif
